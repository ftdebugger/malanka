Content = (EscapedString / DocType / Comment / BalancedTag / SelfClosingTag / BlockExpression / ExpressionComment / Expression / Text)*

// HTML Doctype
DocType = '<!doctype ' doctype:[^>]* '>' {
    return {
        type: 'DocType',
        content: doctype.join('')
    };
}

// HTML Comment
Comment = '<!--' c:(!'-->' c:. {return c})* '-->' {
    return {
        type: 'Comment',
        content: c.join('')
    };
}


// HTML Tag
BalancedTag = startTag:StartTag content:Content endTag:EndTag {
    if (startTag.name !== endTag) {
        error('Expected </' + startTag.name + '> but </' + endTag + '> found.');
    }

    return {
        type: 'BalancedTag',
        name: startTag.name,
        attributes: startTag.attributes,
        content: content
    };
}

SelfClosingTag = '<' name:TagName attributes:Attributes? __? '/>' {
    return {
        type: 'SelfClosingTag',
        name: name,
        attributes: attributes
    };
}

StartTag = '<' name:TagName attributes:Attributes? __? '>' {
    return {
        name: name,
        attributes: attributes
    };
}

EndTag = '</' name:TagName '>' { return name }

TagName = [a-zA-Z0-9]+ { return text() }


// Tag Attributes
Attributes = __ attributes:Attribute* { return attributes }

Attribute = __? attr:(ValuedAttribute / ValuelessAttribute) { return attr }

ValuedAttribute = name:AttributeName '=' value:ValuedAttributeData {
    return {
        name: name,
        value: value
    };
}

ValuelessAttribute = name:AttributeName {
    return {
        name: name,
        value: null
    };
}

AttributeName = '#'? [a-zA-Z0-9\-]+ { return text() }

ValuedAttributeData
    = EscapedString
    / Primitive
    / CallExpression
    / Expression
    / BlockExpression
    / ExpressionPath
    / QuotedString


// Text
Text
    = '{' [^{]+ {
        return {
            type: 'Text',
            content: text()
        };
    }
    / [^<{]+ {
        return {
            type: 'Text',
            content: text()
        };
    }


// Strings
QuotedString = '"' content:(Expression / BlockExpression / String)* '"' { return content }

String = data:StringData+ { return data.join('') }
StringData
    = [^"\\#{]
    / '\\0' !DecimalDigit { return '\0' }
    / '\\0' &DecimalDigit { error('Octal escape sequence is not supported') }
    / '\\b' { return '\b' }
    / '\\t' { return '\t' }
    / '\\n' { return '\n' }
    / '\\v' { return '\v' }
    / '\\f' { return '\f' }
    / '\\r' { return '\r' }
    / '\\' c:. { return c }
    / '#' !'{' { return '#' }


EscapedString
    = '```' { return ['`'] }
    / '\\`' { return ['`'] }
    / '`' text:(!'`' c:. {return c})* '`' { return [text.join('')] }


// Expressions
ExpressionPath = name:ExpressionName {
    return {
        type: 'Path',
        path: name
    };
}

ExpressionName = (!'else' [@_a-zA-Z_0-9.]+) { return text() }

ExpressionAttribute
    = __ value:Primitive { return value }
    / __ value:EscapedString { return value }
    / __ path:ExpressionPath (!'=') { return path }
    / __ helper:InlineExpression { return helper }
    / __ string:QuotedString { return string }

ExpressionAttributes = ExpressionAttribute+

ExpressionHashValue
    = Primitive
    / EscapedString
    / ExpressionPath
    / InlineExpression
    / QuotedString

ExpressionHashAttribute = __ name:ExpressionName '=' value:ExpressionHashValue {
    return {
        name: name,
        value: value
    };
}

ExpressionHash = ExpressionHashAttribute+

Expression = '{{' body:(ShortIfExpressionBody / ExpressionBody) '}}' { return body }

ExpressionBody = path:ExpressionName params:ExpressionAttributes? hash:ExpressionHash? __? {
    return {
        type: 'Expression',
        path: path,
        params: params,
        hash: hash
    };
}

ShortIfExpression = '{{' body:ShortIfExpressionBody '}}' { return body }
ShortIfExpressionBody
	= path:ExpressionPath __? '?' content:ExpressionAttribute __? inverse:(':' inverse:ExpressionAttribute __? {return inverse})? {
        return {
            type: 'BlockExpression',
            path: 'if',
            params: [path],
            hash: null,
            content: [content],
            inverse: inverse ? [inverse] : null
        }
    }
    / path:ExpressionPath __? '?:' inverse:ExpressionAttribute {
    	return {
            type: 'BlockExpression',
            path: 'if',
            params: [path],
            hash: null,
            content: [{
            	type: 'Expression',
                path: path.path,
                params: null,
                hash: null
            }],
            inverse: [inverse]
        }
    }

StartBlockExpression = '{{#' path:ExpressionName attributes:ExpressionAttributes? hash:ExpressionHash? __? '}}' {
    return {
        path: path,
        attributes: attributes,
        hash: hash
    };
}

CloseBlockExpression = '{{/' name:ExpressionName '}}' { return name }

InverseBlockExpression = '{{else}}' content:Content { return content }

BlockExpression = start:StartBlockExpression content:Content? inverse:InverseBlockExpression? close:CloseBlockExpression {
    if (start.path !== close) {
        error('Unmatched block expression. Expected {{/' + start.path + '}} but {{/' + close + '}} found.');
    }

    return {
        type: 'BlockExpression',
        path: start.path,
        params: start.attributes,
        hash: start.hash,
        content: content,
        inverse: inverse
    };
}

InlineExpression = '(' body:(ShortIfExpressionBody / ExpressionBody) ')' { return body }

CallExpressionAttribute
    = ',' value:CallExpressionAttribute { return value }
    / __? value:ExpressionHashValue { return value }

CallExpressionAttributes = CallExpressionAttribute*

CallExpression = path:ExpressionName '(' params:CallExpressionAttributes ')' {
    return {
        type: 'CallExpression',
        path: path,
        params: params
    };
}


ExpressionComment
    = '{{!--' c:(!'--}}' c:. {return c} )* '--}}' {
        return {
            type: 'Comment',
            content: c.join('')
        };
    }
    / '{{!' c:(!'}}' c:. {return c} )* '}}' {
        return {
            type: 'Comment',
            content: c.join('')
        };
    }


// Primitives
Primitive
    = 'false' { return {type: 'Primitive', value: false} }
    / 'true' { return {type: 'Primitive', value: true} }
    / 'null' { return {type: 'Primitive', value: null} }
    / 'undefined' { return {type: 'Primitive', value: undefined} }
    / SignedInteger '.' DecimalDigit+ { return {type: 'Primitive', value: Number(text())} }
    / SignedInteger { return {type: 'Primitive', value: Number(text())} }


SignedInteger = [+-]? DecimalDigit+

DecimalDigit = [0-9]


// Consts
spaces = [ \t\r\n]+

__ = spaces
