Content = (EscapedString / DocType / Comment / BalancedTag / SelfClosingTag / BlockExpression / ExpressionComment / Expression / Text)*

DocType = "<!doctype " doctype:[^>]* ">" {
    return {
        type: 'DocType',
        content: doctype.join('')
    };
}

Comment = "<!--" c:(!"-->" c:. {return c})* "-->" {
    return {
        type: 'Comment',
        content: c.join('')
    };
}

BalancedTag = startTag:StartTag content:Content endTag:EndTag {
    if (startTag.name != endTag) {
        throw new Error("Expected </" + startTag.name + "> but </" + endTag + "> found.");
    }

    return {
      type: 'BalancedTag',
      name: startTag.name,
      attributes: startTag.attributes,
      content: content
    };
  }

SelfClosingTag = "<" name:TagName attributes:Attributes? spaces? "/>" {
    return {
      type: 'SelfClosingTag',
      name: name,
      attributes: attributes
    };
  }

StartTag = "<" name:TagName attributes:Attributes? spaces? ">" {
  return {
    name: name,
    attributes: attributes
  }
}

EndTag = "</" name:TagName ">" { return name; }

Attributes = spaces attributes:Attribute* { return attributes; }

Attribute = spaces? attr:(ValuedAttribute / ValuelessAttribute) { return attr; }

ValuedAttribute
  = name:AttributeName "=" value:(EscapedString / CallExpression / Primitive / Expression / ExpressionPath / AttributeValue) {
    return {
      name: name,
      value: value
    };
  }

ValuelessAttribute = name:AttributeName {
  return {
    name: name,
    value: null
  };
}

AttributeName = chars:[a-zA-Z0-9\-]+ { return chars.join(""); }
AttributeValue = (QuotedAttributeValue / UnquotedAttributeValue)

QuotedAttributeValue = value:QuotedString { return value; }

UnquotedAttributeValue = value:decimalDigit* { return value.join(''); }

TagName = chars:[a-zA-Z0-9]+ { return chars.join(""); }

Text
  = open:'{' chars:[^{]+ {
  	return {
    	type: 'Text',
        content: open + chars.join('')
    }
  }
  / chars:[^<{]+  {
    return {
      type: 'Text',
      content: chars.join("")
    }
  }


decimalDigit = [0-9]


QuotedString = quoteStart:('"'/"'") chars:[a-zA-Z0-9://\.-]+ quoteEnd:('"'/"'") {
  if (quoteStart != quoteEnd) {
    throw new Error("Unmatched quote; Expected " + quoteStart + " but " + quoteEnd + " found.");
  }
  return chars.join("");
}

QuotedString
  = "\"" content:(Expression / BlockExpression / string)* "\"" {
  	return content;
  }
  string = data:stringData+ { return data.join('') }
  stringData
    = [^"\\#{]
    / "\\0" !decimalDigit { '\0' }
    / "\\0" &decimalDigit { throw new SyntaxError ['string data'], 'octal escape sequence', offset(), line(), column() }
    / "\\b" { '\b' }
    / "\\t" { '\t' }
    / "\\n" { '\n' }
    / "\\v" { '\v' }
    / "\\f" { '\f' }
    / "\\r" { '\r' }
    / "\\" c:. { c }
    / c:"#" !"{" { c }

EscapedString
	= '```' { return ['`'] }
    / '\\`' { return ['`'] }
	/'`' text:(!'`' c:. {return c})* '`' { return [text.join('')] }

ExpressionPath = path:[@_a-zA-Z.0-9]+ {
	return {
    	type: 'Path',
        path: path.join('')
    };
}

ExpressionName = (!'else' name:[@_a-zA-Z_0-9.]+) { return name.join('') }

ExpressionAttribute
	= spaces value:Primitive { return value }
    / spaces value:EscapedString { return value }
    / spaces path:ExpressionPath (!'=') { return path; }
    / spaces helper:InlineExpression { return helper; }
	/ spaces string:QuotedString { return string; }
ExpressionAttributes = attributes:ExpressionAttribute+ { return attributes }

ExpressionHashValue
	= value:Primitive { return value }
    / value:EscapedString { return value }
    / path:ExpressionPath { return path }
    / helper:InlineExpression { return helper; }
    / string:QuotedString { return string }

ExpressionHashAttribute = spaces name:ExpressionName '=' value:ExpressionHashValue {
	return {
    	name: name,
        value: value
    }
}

ExpressionHash = attrs:ExpressionHashAttribute+ { return attrs; }

Expression = open:'{{' path:ExpressionName params:ExpressionAttributes? hash:ExpressionHash? spaces? close:'}}' {
    return {
        type: 'Expression',
        path: path,
        params: params,
        hash: hash
    };
}

StartBlockExpression = open:'{{#' path:ExpressionName attributes:ExpressionAttributes? hash:ExpressionHash? spaces? close:'}}' {
    return {
        path: path,
        attributes: attributes,
        hash: hash
    }
}

CloseBlockExpression = open:'{{/' name:ExpressionName close:'}}' { return name; }

InverseBlockExpression = '{{else}}' content:Content { return content; }

BlockExpression = start:StartBlockExpression content:Content? inverse:InverseBlockExpression? close:CloseBlockExpression {
	if (start.path !== close) {
        throw new Error("Unmatched block expression. Expected " + start.name + " but " + close.name + " found.");
    }

    return {
        type: 'BlockExpression',
        path: start.path,
        params: start.attributes,
        hash: start.hash,
        content: content,
        inverse: inverse
    }
}

InlineExpression = '(' path:ExpressionName params:ExpressionAttributes? hash:ExpressionHash? spaces? ')' {
	return {
    	type: 'Expression',
        path: path,
        params: params,
        hash: hash
    }
}
CallExpressionAtribute
	= ',' value:CallExpressionAtribute {return value}
	/ spaces? value:ExpressionHashValue {return value}

CallExpressionAtributes = CallExpressionAtribute*

CallExpression = path:ExpressionName '(' params:CallExpressionAtributes ')' {
	return {
    	type: 'CallExpression',
        path: path,
        params: params
    }
}

ExpressionComment
	= '{{!--' c:(!'--}}' c:. {return c} )* '--}}' {
        return {
            type: 'Comment',
            content: c.join('')
        };
    }
    / '{{!' c:(!'}}' c:. {return c} )* '}}' {
        return {
            type: 'Comment',
            content: c.join('')
        };
    }

Primitive
	= 'false' { return {type: 'Primitive', value: false} }
    / 'true' { return {type: 'Primitive', value: true} }
    / 'null' { return {type: 'Primitive', value: null} }
    / 'undefined' { return {type: 'Primitive', value: undefined} }
    / nums:([0-9]+) d:(d:'.' n:[0-9]+ { return d + n.join('') }) {
    	return {type: 'Primitive', value: Number(nums.join('') + d)}
    }
    / nums:([0-9]+) {
    	return {type: 'Primitive', value: Number(nums.join(''))}
    }

spaces = [ \t\r\n]+